package telegram

import (
	"context"
	"fmt"
	"sync"
	"time"
)

// Message represents a message sent by the bot
type Message struct {
	ID        int64
	ChatID    int64
	Text      string
	Timestamp time.Time
}

// BotAPI interface for Telegram bot operations (allows mocking in tests)
type BotAPI interface {
	SendMessage(chatID int64, text string) error
	GetUpdates() ([]Message, error)
}

// State represents the FSM state for user conversations
type State string

const (
	StateIdle          State = "idle"
	StateWaitingMute   State = "waiting_mute"
	StateWaitingSwitch State = "waiting_switch"
	StateConfirming    State = "confirming"
)

// UserSession represents a user conversation session
type UserSession struct {
	UserID    int64
	State     State
	Data      map[string]interface{}
	UpdatedAt time.Time
}

// RateLimiter implements token bucket algorithm for rate limiting
type RateLimiter struct {
	rate       int // messages per minute
	bucketSize int // burst size
	tokens     float64
	lastUpdate time.Time
	mu         sync.Mutex
}

// NewRateLimiter creates a new rate limiter
func NewRateLimiter(messagesPerMinute int) *RateLimiter {
	return &RateLimiter{
		rate:       messagesPerMinute,
		bucketSize: messagesPerMinute,
		tokens:     float64(messagesPerMinute),
		lastUpdate: time.Now(),
	}
}

// Allow checks if a message can be sent
func (rl *RateLimiter) Allow() bool {
	rl.mu.Lock()
	defer rl.mu.Unlock()

	now := time.Now()
	elapsed := now.Sub(rl.lastUpdate).Minutes()
	rl.lastUpdate = now

	// Add tokens based on elapsed time
	rl.tokens += float64(rl.rate) * elapsed
	if rl.tokens > float64(rl.bucketSize) {
		rl.tokens = float64(rl.bucketSize)
	}

	if rl.tokens >= 1 {
		rl.tokens--
		return true
	}
	return false
}

// DedupLimiter prevents duplicate messages within a time window
type DedupLimiter struct {
	sent   map[string]time.Time
	window time.Duration
	mu     sync.RWMutex
}

// NewDedupLimiter creates a new deduplication limiter
func NewDedupLimiter(window time.Duration) *DedupLimiter {
	return &DedupLimiter{
		sent:   make(map[string]time.Time),
		window: window,
	}
}

// CanSend checks if a message can be sent (not a duplicate)
func (dl *DedupLimiter) CanSend(key string) bool {
	dl.mu.Lock()
	defer dl.mu.Unlock()

	now := time.Now()
	if sentAt, exists := dl.sent[key]; exists {
		if now.Sub(sentAt) < dl.window {
			return false
		}
	}
	dl.sent[key] = now
	return true
}

// Cleanup removes old entries from the dedup limiter
func (dl *DedupLimiter) Cleanup() {
	dl.mu.Lock()
	defer dl.mu.Unlock()

	now := time.Now()
	for key, sentAt := range dl.sent {
		if now.Sub(sentAt) > dl.window {
			delete(dl.sent, key)
		}
	}
}

// Alert represents an alert to be sent
type Alert struct {
	ID        string
	Severity  string
	Message   string
	AccountID string
	Timestamp time.Time
}

// BotOptions contains optional configuration for the bot
type BotOptions struct {
	RateLimiter  *RateLimiter
	DedupLimiter *DedupLimiter
	BotAPI       BotAPI
}

// Bot represents the Telegram bot for QuotaGuard
type Bot struct {
	botToken    string
	chatID      int64
	enabled     bool
	rateLimiter *RateLimiter
	dedup       *DedupLimiter
	sessions    map[int64]*UserSession
	sessionsMu  sync.RWMutex
	api         BotAPI

	// Context for graceful shutdown
	ctx    context.Context
	cancel context.CancelFunc
	wg     sync.WaitGroup

	// Channels
	msgChan   chan Message
	alertChan chan Alert

	// Callbacks for command handlers
	onGetStatus      func() (*SystemStatus, error)
	onGetQuotas      func() ([]AccountQuota, error)
	onGetAlerts      func() ([]ActiveAlert, error)
	onMuteAlerts     func(duration time.Duration) error
	onForceSwitch    func(accountID string) error
	onGetDailyDigest func() (*DailyDigest, error)
}

// SystemStatus represents the system status
type SystemStatus struct {
	AccountsActive int
	RouterStatus   string
	AvgLatency     time.Duration
	LastUpdate     time.Time
}

// AccountQuota represents quota info for an account
type AccountQuota struct {
	AccountID    string
	Provider     string
	UsagePercent float64
	IsWarning    bool
}

// ActiveAlert represents an active alert
type ActiveAlert struct {
	ID       string
	Severity string
	Message  string
	Time     time.Time
}

// DailyDigest represents the daily statistics
type DailyDigest struct {
	Date          time.Time
	TotalRequests int64
	Switches      int
	Errors        int
	TopAccounts   []string
}

// NewBot creates a new Telegram bot
func NewBot(botToken string, chatID int64, enabled bool, opts *BotOptions) *Bot {
	ctx, cancel := context.WithCancel(context.Background())

	b := &Bot{
		botToken:  botToken,
		chatID:    chatID,
		enabled:   enabled,
		sessions:  make(map[int64]*UserSession),
		ctx:       ctx,
		cancel:    cancel,
		msgChan:   make(chan Message, 100),
		alertChan: make(chan Alert, 100),
	}

	if opts != nil {
		if opts.RateLimiter != nil {
			b.rateLimiter = opts.RateLimiter
		}
		if opts.DedupLimiter != nil {
			b.dedup = opts.DedupLimiter
		}
		if opts.BotAPI != nil {
			b.api = opts.BotAPI
		}
	}

	// Set default rate limiter if not provided
	if b.rateLimiter == nil {
		b.rateLimiter = NewRateLimiter(30) // 30 messages per minute
	}

	// Set default dedup limiter if not provided
	if b.dedup == nil {
		b.dedup = NewDedupLimiter(5 * time.Minute)
	}

	return b
}

// SetStatusCallback sets the callback for getting system status
func (b *Bot) SetStatusCallback(cb func() (*SystemStatus, error)) {
	b.onGetStatus = cb
}

// SetQuotasCallback sets the callback for getting quotas
func (b *Bot) SetQuotasCallback(cb func() ([]AccountQuota, error)) {
	b.onGetQuotas = cb
}

// SetAlertsCallback sets the callback for getting alerts
func (b *Bot) SetAlertsCallback(cb func() ([]ActiveAlert, error)) {
	b.onGetAlerts = cb
}

// SetMuteCallback sets the callback for muting alerts
func (b *Bot) SetMuteCallback(cb func(duration time.Duration) error) {
	b.onMuteAlerts = cb
}

// SetForceSwitchCallback sets the callback for force switching
func (b *Bot) SetForceSwitchCallback(cb func(accountID string) error) {
	b.onForceSwitch = cb
}

// SetDailyDigestCallback sets the callback for daily digest
func (b *Bot) SetDailyDigestCallback(cb func() (*DailyDigest, error)) {
	b.onGetDailyDigest = cb
}

// Start starts the bot
func (b *Bot) Start() error {
	if !b.enabled {
		return nil
	}

	if b.botToken == "" {
		return fmt.Errorf("bot token is required")
	}

	// Start message processing loop
	b.wg.Add(1)
	go b.processMessages()

	// Start alert processing loop
	b.wg.Add(1)
	go b.processAlerts()

	// Start daily digest scheduler
	b.wg.Add(1)
	go b.scheduleDailyDigest()

	// Start dedup cleanup
	b.wg.Add(1)
	go b.dedupCleanup()

	return nil
}

// Stop gracefully stops the bot
func (b *Bot) Stop() error {
	b.cancel()

	// Close channels
	close(b.msgChan)
	close(b.alertChan)

	// Wait for all goroutines to finish
	done := make(chan struct{})
	go func() {
		b.wg.Wait()
		close(done)
	}()

	select {
	case <-done:
		return nil
	case <-time.After(30 * time.Second):
		return fmt.Errorf("timeout waiting for bot to stop")
	}
}

// processMessages processes incoming messages
func (b *Bot) processMessages() {
	defer b.wg.Done()

	for {
		select {
		case <-b.ctx.Done():
			return
		case msg, ok := <-b.msgChan:
			if !ok {
				return
			}
			b.handleMessage(msg)
		}
	}
}

// processAlerts processes outgoing alerts
func (b *Bot) processAlerts() {
	defer b.wg.Done()

	for {
		select {
		case <-b.ctx.Done():
			return
		case alert, ok := <-b.alertChan:
			if !ok {
				return
			}
			b.handleAlert(alert)
		}
	}
}

// scheduleDailyDigest schedules and sends daily digest
func (b *Bot) scheduleDailyDigest() {
	defer b.wg.Done()

	ticker := time.NewTicker(24 * time.Hour)
	defer ticker.Stop()

	// Schedule for a specific time (e.g., 9:00 AM)
	for {
		select {
		case <-b.ctx.Done():
			return
		case <-ticker.C:
			b.sendDailyDigest()
		}
	}
}

// dedupCleanup periodically cleans up old dedup entries
func (b *Bot) dedupCleanup() {
	defer b.wg.Done()

	ticker := time.NewTicker(10 * time.Minute)
	defer ticker.Stop()

	for {
		select {
		case <-b.ctx.Done():
			return
		case <-ticker.C:
			b.dedup.Cleanup()
		}
	}
}

// SendMessage sends a message to the configured chat
func (b *Bot) SendMessage(text string) error {
	if !b.enabled {
		return nil
	}

	if !b.rateLimiter.Allow() {
		return fmt.Errorf("rate limit exceeded")
	}

	if b.api != nil {
		return b.api.SendMessage(b.chatID, text)
	}

	return nil
}

// SendAlert sends an alert with deduplication
func (b *Bot) SendAlert(alert Alert) error {
	if !b.enabled {
		return nil
	}

	// Check deduplication
	key := fmt.Sprintf("alert:%s:%s", alert.ID, alert.Severity)
	if !b.dedup.CanSend(key) {
		return nil
	}

	select {
	case b.alertChan <- alert:
		return nil
	default:
		return fmt.Errorf("alert channel is full")
	}
}

// GetSession gets or creates a user session
func (b *Bot) GetSession(userID int64) *UserSession {
	b.sessionsMu.Lock()
	defer b.sessionsMu.Unlock()

	if session, ok := b.sessions[userID]; ok {
		session.UpdatedAt = time.Now()
		return session
	}

	session := &UserSession{
		UserID:    userID,
		State:     StateIdle,
		Data:      make(map[string]interface{}),
		UpdatedAt: time.Now(),
	}
	b.sessions[userID] = session
	return session
}

// SetSessionState sets the state for a user session
func (b *Bot) SetSessionState(userID int64, state State, data map[string]interface{}) {
	b.sessionsMu.Lock()
	defer b.sessionsMu.Unlock()

	if session, ok := b.sessions[userID]; ok {
		session.State = state
		if data != nil {
			session.Data = data
		}
		session.UpdatedAt = time.Now()
	}
}

// ClearSession clears a user session
func (b *Bot) ClearSession(userID int64) {
	b.sessionsMu.Lock()
	defer b.sessionsMu.Unlock()

	delete(b.sessions, userID)
}

// CleanupSessions removes old sessions
func (b *Bot) CleanupSessions(maxAge time.Duration) {
	b.sessionsMu.Lock()
	defer b.sessionsMu.Unlock()

	now := time.Now()
	for userID, session := range b.sessions {
		if now.Sub(session.UpdatedAt) > maxAge {
			delete(b.sessions, userID)
		}
	}
}

// IsEnabled returns whether the bot is enabled
func (b *Bot) IsEnabled() bool {
	return b.enabled
}

// GetChatID returns the configured chat ID
func (b *Bot) GetChatID() int64 {
	return b.chatID
}
